{"ast":null,"code":"// this is the redux with the redux-toolkit\n// there ere two function for crating reducer function \" createSlice \" & \" createReducer \" but create slice is more powerFull than createReducer that's why here we will use the Slice\n// here configureStore will create a store like createStore but it's make merging multiple reducers into one reducer easier thereafter \nimport { createSlice, configureStore } from '@reduxjs/toolkit';\nconst initialState = {\n  counter: 0,\n  showCounter: true\n};\n\n// after creating call it like that \n// here we are preparing our slice for the global state and when we have different pieces of state which are not directly related (like authentication state and counter state) we could create different slices potentially in different files to make our code maintainable \n// here we just have one state counter state that's we will create just one slice \n// here we have to use return value of calling createSlice because here we get back our data\nconst counterSlice = createSlice({\n  // this is the identifier which every slice needs \n  name: 'counter',\n  // after identifier you have to set up an initial state \n  initialState,\n  // after that initial value you have to add reducers is again an object of all the reducers this slice needed \n  // here Slice will generate unique identifier for every reducer function where the key names are increment , decrement and so on which will match the method name we have in our createSlice function in the reducers area \n  reducers: {\n    // now here we have to create every method that is needed for that slice of state \n    // here every method will get latest state automatically \n    increment(state) {\n      // here we can mutate the state directly in the ReduxToolkit because toolkit calls imgur behind the scenes and create the clone of the existing state and keep all the states which we are not editing , and override the state which we are editing in s immutable way.\n      // but this is not allowed when you are not using the redux-toolkit \n      state.counter++;\n    },\n    decrement(state) {\n      state.counter--;\n    },\n    // here we need an extra payload action \n    // we don't have to accept action in other reducers because there we don't need it \n    increase(state, action) {\n      state.counter += action.payload;\n    },\n    toggleCounter(state) {\n      state.showCounter = !state.showCounter;\n    }\n  }\n});\ncreateSlice();\n\n// here in configureStore we have to pass an object which is a configuration object where we then set reducer property \nconst store = configureStore({\n  // here we are using reducer only one single reducer function because redux only wants one main reducer function , which is responsible for one global state\n  reducer: counterSlice.reducer\n\n  // here when we have multiple slices than alternatively as a value for this reducer key , we can also set an object and in the object , we can set up any keys of our choice and the values of those keys will be different reducer functions ,  So we should create a map of reducers you could say and this map is then set as a value for the main reducer and behind the scenes configureStore will emerge all those reducers into one big reducer \n  // here we don't have multiple slice that's why we are not using object here but we can use it like this . you can add multiple keys for multiple slice \n  // reducer : { counter : counterSlice.reducer }\n});\n\n// this will return an object of this shape  : { type : ' some auto generated unique identifier ' }\n// so here we don't have to worry about the unique action identifiers createSlice will create for us \nexport const counterActions = counterSlice.actions;\nexport default store;\n\n// this is normal redux \n\n// import { createStore } from 'redux';\n\n// const initialValue = { counter : 0 , showCounter : true }\n\n// const Counterreducer = (state = initialValue , action)=>{\n//     if(action.type === 'increment'){\n//         return state = {\n//             counter : state.counter + 1 ,\n//             showCounter : state.showCounter\n//         }\n//     }\n//     // we can not add types like that i=this will be not good way because this will lead us to mush larger conditions that's why now we use actions to pass some values \n//     // if(action.type === 'increaseBy5'){\n//     //     return state = {\n//     //         counter : state.counter + 5 ,\n//     //     }\n//     // }\n//     // for now not repeating the value we will create a general state \n//     if(action.type === 'increase'){\n//         return state = {\n//             counter : state.counter + action.amount ,\n//             showCounter : state.showCounter\n//         }\n//     }\n//     if(action.type === 'decrement'){\n//         return state = {\n//             counter : state.counter - 1 ,\n//             showCounter : state.showCounter\n//         }\n//     }\n\n//     if(action.type === 'toggle'){\n//         return state = { \n//             counter : state.counter ,\n//             showCounter : !state.showCounter ,\n//         }\n//     }\n//     return state ;\n// }\n\n// const store = createStore(Counterreducer);\n\n// export default store ;\n// // now we have to provide this store to the every component of the project so they can use the state for that we will wrap the main app component and than with doing that all the components can have access to the store","map":{"version":3,"names":["createSlice","configureStore","initialState","counter","showCounter","counterSlice","name","reducers","increment","state","decrement","increase","action","payload","toggleCounter","store","reducer","counterActions","actions"],"sources":["/home/ompatel/Desktop/REACT.JS/practice/21-redux-basic-project/src/Store/reduxIndex.js"],"sourcesContent":["// this is the redux with the redux-toolkit\n// there ere two function for crating reducer function \" createSlice \" & \" createReducer \" but create slice is more powerFull than createReducer that's why here we will use the Slice\n// here configureStore will create a store like createStore but it's make merging multiple reducers into one reducer easier thereafter \nimport { createSlice , configureStore } from '@reduxjs/toolkit';\n\n\nconst initialState = { counter : 0 , showCounter : true }\n\n// after creating call it like that \n// here we are preparing our slice for the global state and when we have different pieces of state which are not directly related (like authentication state and counter state) we could create different slices potentially in different files to make our code maintainable \n// here we just have one state counter state that's we will create just one slice \n// here we have to use return value of calling createSlice because here we get back our data\nconst counterSlice  = createSlice({\n    // this is the identifier which every slice needs \n    name : 'counter',\n    // after identifier you have to set up an initial state \n    initialState,\n    // after that initial value you have to add reducers is again an object of all the reducers this slice needed \n    // here Slice will generate unique identifier for every reducer function where the key names are increment , decrement and so on which will match the method name we have in our createSlice function in the reducers area \n    reducers : {\n        // now here we have to create every method that is needed for that slice of state \n        // here every method will get latest state automatically \n        increment(state) {\n            // here we can mutate the state directly in the ReduxToolkit because toolkit calls imgur behind the scenes and create the clone of the existing state and keep all the states which we are not editing , and override the state which we are editing in s immutable way.\n            // but this is not allowed when you are not using the redux-toolkit \n            state.counter++;\n        },\n        decrement(state) {\n            state.counter--;\n        },\n        // here we need an extra payload action \n        // we don't have to accept action in other reducers because there we don't need it \n        increase(state , action ) {\n            state.counter += action.payload ;\n        },\n        toggleCounter(state) {\n            state.showCounter = !state.showCounter;\n        }\n    }\n});\n\ncreateSlice()\n\n// here in configureStore we have to pass an object which is a configuration object where we then set reducer property \nconst store = configureStore({\n    // here we are using reducer only one single reducer function because redux only wants one main reducer function , which is responsible for one global state\n    reducer : counterSlice.reducer \n\n    // here when we have multiple slices than alternatively as a value for this reducer key , we can also set an object and in the object , we can set up any keys of our choice and the values of those keys will be different reducer functions ,  So we should create a map of reducers you could say and this map is then set as a value for the main reducer and behind the scenes configureStore will emerge all those reducers into one big reducer \n    // here we don't have multiple slice that's why we are not using object here but we can use it like this . you can add multiple keys for multiple slice \n    // reducer : { counter : counterSlice.reducer }\n});\n\n// this will return an object of this shape  : { type : ' some auto generated unique identifier ' }\n// so here we don't have to worry about the unique action identifiers createSlice will create for us \nexport const counterActions = counterSlice.actions;\n\nexport default store ;\n\n// this is normal redux \n\n// import { createStore } from 'redux';\n\n\n// const initialValue = { counter : 0 , showCounter : true }\n\n// const Counterreducer = (state = initialValue , action)=>{\n//     if(action.type === 'increment'){\n//         return state = {\n//             counter : state.counter + 1 ,\n//             showCounter : state.showCounter\n//         }\n//     }\n//     // we can not add types like that i=this will be not good way because this will lead us to mush larger conditions that's why now we use actions to pass some values \n//     // if(action.type === 'increaseBy5'){\n//     //     return state = {\n//     //         counter : state.counter + 5 ,\n//     //     }\n//     // }\n//     // for now not repeating the value we will create a general state \n//     if(action.type === 'increase'){\n//         return state = {\n//             counter : state.counter + action.amount ,\n//             showCounter : state.showCounter\n//         }\n//     }\n//     if(action.type === 'decrement'){\n//         return state = {\n//             counter : state.counter - 1 ,\n//             showCounter : state.showCounter\n//         }\n//     }\n\n//     if(action.type === 'toggle'){\n//         return state = { \n//             counter : state.counter ,\n//             showCounter : !state.showCounter ,\n//         }\n//     }\n//     return state ;\n// }\n\n// const store = createStore(Counterreducer);\n\n// export default store ;\n// // now we have to provide this store to the every component of the project so they can use the state for that we will wrap the main app component and than with doing that all the components can have access to the store "],"mappings":"AAAA;AACA;AACA;AACA,SAASA,WAAW,EAAGC,cAAc,QAAQ,kBAAkB;AAG/D,MAAMC,YAAY,GAAG;EAAEC,OAAO,EAAG,CAAC;EAAGC,WAAW,EAAG;AAAK,CAAC;;AAEzD;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAIL,WAAW,CAAC;EAC9B;EACAM,IAAI,EAAG,SAAS;EAChB;EACAJ,YAAY;EACZ;EACA;EACAK,QAAQ,EAAG;IACP;IACA;IACAC,SAASA,CAACC,KAAK,EAAE;MACb;MACA;MACAA,KAAK,CAACN,OAAO,EAAE;IACnB,CAAC;IACDO,SAASA,CAACD,KAAK,EAAE;MACbA,KAAK,CAACN,OAAO,EAAE;IACnB,CAAC;IACD;IACA;IACAQ,QAAQA,CAACF,KAAK,EAAGG,MAAM,EAAG;MACtBH,KAAK,CAACN,OAAO,IAAIS,MAAM,CAACC,OAAO;IACnC,CAAC;IACDC,aAAaA,CAACL,KAAK,EAAE;MACjBA,KAAK,CAACL,WAAW,GAAG,CAACK,KAAK,CAACL,WAAW;IAC1C;EACJ;AACJ,CAAC,CAAC;AAEFJ,WAAW,CAAC,CAAC;;AAEb;AACA,MAAMe,KAAK,GAAGd,cAAc,CAAC;EACzB;EACAe,OAAO,EAAGX,YAAY,CAACW;;EAEvB;EACA;EACA;AACJ,CAAC,CAAC;;AAEF;AACA;AACA,OAAO,MAAMC,cAAc,GAAGZ,YAAY,CAACa,OAAO;AAElD,eAAeH,KAAK;;AAEpB;;AAEA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}